function system_init(nodeNum_arg,distribution_arg)
%INIT_SIMU 初始化仿真场景。
%  包括：结点结点数据、仿真系统所要用到地图。
%初始化结点
global round_count  is_code_finished;
%<global init>
set_env(nodeNum_arg,distribution_arg);
put_nodes_in_grid();
construct_phy_NBor_map();
init_decode_context();
init_statis_context();

%全局控制信号
round_count = 1;%当前round号
is_code_finished = 1;
end

function set_env(nodeNum_arg,distribution_arg)
global comRange	  nodeMemSize     sensor_density ...
       nodeNum    distribution  code_redundence;
   
nodeNum = nodeNum_arg;%场景下的结点总数。，这个不能改，要改的话，许多函数里面的常数都要改。因为是方格mesh网络。
nodeMemSize = 100;%每个结点可以存储4个包。
code_redundence = 2;%每个码包生成多少个副本
distribution = distribution_arg;%初始化度分布
comRange = 10;%communication range
 % phyNBorMap:物理场景下，在通信范围内的邻结点。结点自身不一定发现了这些邻结点。这个map用于模拟信道通信距离。
sensor_density = 2;%结点密度：单个结点通信面积*结点总数/布置面积
end
function init_decode_context()
global decode_context;
%初始化解码环境
decode_context.k = floor(0.98*nodeNum);
decode_context.is_finished = 0;
decode_context.decoded_processed = zeros(1,nodeNum);
decode_context.decoded_unprocessed = [];
%记录下，每个还没被解码出来的原始码被哪些已收到的码字依赖。
%当原始码被解出来后，就可以根据这个表来消除他们的冗余分量
decode_context.future_decode_register = cell(1,nodeNum);
decode_context.undecoded_codes = [];
%find indx table
decode_context.indx_table = 1:nodeNum;
decode_context.receive_counter = 0;
end
function init_statis_context()
global statis;
%初始化统计环境
statis.degree_statis = zeros(1,nodeNum);
statis.hop_statis = 0;
statis.max_path_len = 0;
statis.is_data_valid = 1;
statis.num_statis = 1;
end
%
%node mem size:总缓存空间
%refuse reception threshold:当缓存占用多少时，拒绝接收新包
%code redundence:每个符号生成多少个重复码包
%
function put_nodes_in_grid()
%目标功能：
%在尽可能接近正方形的平面空间内，按照预定密度放置所有结点。为此，可以稍微修改节点的总数。
%要求网络为网格拓扑。
%要求结点被初始化，生成目标度各不相同，但含有相同原始符号的码包。
    global nodes nodeNum sensor_density comRange code_redundence grid_width nx ny;%收集时，绕的圈数;
    %使得区域近乎方形，并调整结点的数量
    n = sqrt(nodeNum);
    nx = floor(n);
    ny = ceil(n);
    nodeNum = nx*ny;
    
    grid_width = sqrt(comRange^2/sensor_density);
    dis = grid_width;
    
    for k=1:nodeNum
        nodes(k).id = k;
        
        x = mod(k-1,nx)*dis;
        y = floor((k-1)/nx)*dis;
        nodes(k).pos = [x,y];
        nodes(k).neigborNum = 0;%具体的邻结点在通信过程中更新，这个属性是为使访问不出界。
        
        %<初始码包>-----------------------------------------------
        %--下一次编码前，还需传输的跳数
        pack.left_hop = int32(log(nodeNum));
        
        %--构造编码系数
        tmp = int32(zeros(1,nodeNum));
        tmp(k) = int32(1);  
        pack.coeffs = tmp;
        
        %--复制b个初始包，放入“未完成编码码包”链表中。
        list = doubleLinkedList();
        for counter=1:code_redundence
            pack.left_degree = int32(get_target_degree() - 1);
            new_node = dlnode(pack);
            ListInsert(list, new_node);
        end
        nodes(k).coding_mems = list;
        %--初始化“已完成编码码包”链表
        nodes(k).code_finished_mems = doubleLinkedList();
        %</初始码包>---------------------------------------------

        nodes(k).is_busy = 0;%used to media access control
        nodes(k).is_collected = 0;
    end
end
function targetDegree = get_target_degree()
    global distribution nodeNum;
    rand_scalar = rand();
    for indx = 1:nodeNum
       if rand_scalar < distribution(indx)
           targetDegree = indx;
           break;
       else
           rand_scalar = rand_scalar - distribution(indx);
       end
    end
end
%density: comRange^2*nodeNum/area
% function init_nodes_random()
% global nodes nodeNum density comRange nodeMemSize;
% area_width = floor(sqrt(comRange.^2*nodeNum/density));
% %id
% %pos
% %neigbor
% %mem
% %hopRank
% for k=1:nodeNum
%     nodes(k).id = k;
%     nodes(k).pos = randi(area_width,1,2);
%     nodes(k).neigborNum = 0;%具体的邻结点在通信过程中更新，这个属性是为使访问不出界。
%     
%     tmp = zeros(1,nodeNum);
%     tmp(k) = 1;
%     nodes(k).mem = ones(nodeMemSize,1)*tmp;%第k个行向量，代表第k个mem上存储的包的系数向量。
%     nodes(k).hopRank = -1;
% end
% nodes(1).pos = [0,0];%将sink放在左下角
% end

function construct_phy_NBor_map()
    global nodes comRange nodeNum phyNBorMap max_nb_num;
    phyNBorMap = zeros(nodeNum,nodeNum);
    for k1 = 1:nodeNum
        for k2 = k1+1:nodeNum
            phyNBorMap(k1,k2) = (norm(nodes(k1).pos - nodes(k2).pos) < comRange);
        end
    end
    phyNBorMap = phyNBorMap + phyNBorMap';
    
    max_nb_num = max(sum(phyNBorMap,1));
end